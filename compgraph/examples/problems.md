#### Word Count

В этой задаче вам дана коллекция документов в формате `{'doc_id':'name', 'text :...'})`. То есть таблица с колонками заголовок - текст. Требуется для каждого из слов, встречающихся в текстах, посчитать количество вхождений во все тексты в сумме.

Результат должен выглядеть так: `{'term' : 'word', 'count' : count}`

#### Инвертированный индекс на tf-idf

Работать будем с тем же датасетом, что и в предыдущей задаче. Для этой коллекции построим *инвертированный индекс* — структуру данных, которая для каждого слова хранит список документов, в котором оно встречается, отсортированный в порядке *релевантности*. Релевантность будем считать по метрике [tf-idf](https://ru.wikipedia.org/wiki/TF-IDF).

Для каждой пары (слово, документ) tf-idf зададим так:
`
TFIDF(word_i, doc_i) = (frequency of word_i in doc_i ) * log((total number of docs) / (docs where word_i is present))
`
Результат должен выглядеть так: `{'term' : 'word', 'index' : [(doc_id_1, tf_idf_1)...]}`

Для каждого слова надо посчитать топ-3 документов по tf-idf.

(Решение этой задачи описано ниже)

#### Топ слов с наибольшей взаимной информацией

Задача, обратная предыдущей: на том же датасете надо для каждого документа посчитать топ-10 слов наиболее характерных для него. Ранжировать слова будем по метрике [Pointwise mutual information](https://en.wikipedia.org/wiki/Pointwise_mutual_information). Более формально задача ставится так: для каждого текста надо найти топ-10 слов, каждое из которых  длиннее четырех символов и встречаются в каждом из документов не менее двух раз; топ надо выбирать по величине
`
pmi(word_i, doc_i) = log((frequency of word_i in doc_i) / (frequency of word_i in all documents combined))
`

#### Средняя скорость движения по городу от часа и дня недели

В этой задаче вам надо работать с информацией о движении людей на машинах по какому-то подмножеству улиц города Москвы.  Улицы города заданы как граф, а информация о передвижении задана как таблица, в каждой строке которой данные вида

`{'edge_id': '624','enter_time':'20170912T123410.1794','leave_time':'20170912T123412.68'}`

где edge_id — идентификатор ребра графа дорог (то есть просто участка какой-то улицы), enter_time и leave_time — соответственно время вьезда и выезда на это ребро (время в utc)

Также вам дана вспомогательная таблица вида

`{'edge_id':'313', 'length':121, 'start':[37.31245, 51.256734], 'end':[37.31245, 51.256734]}`

где length - длина в метрах, start и end — координаты начала и конца ребра, заданные в формате ('lon', 'lat'). Быть может, не для всех рёбер графа есть вся метаифнформация.

Пользуясь этой информацией вам надо построить таблицу со средней скоростью движения  по городу в км/ч в зависимости от часа и дня недели.

`{'weekday' : 'Mon', 'hour' : 4, 'speed' : 44.812}`

Для проверки постройте график по этой таблице, он должен выглядеть предсказуемо.

----

#### Разбор задачи про tf-idf

Решим задачу обратного индекса на tf-idf.

На входе нам дана таблица с колонками (“doc_id”, “text”). Т.е. просто список документов с названиями.

На выходе для каждого слова из исходных документов хотим получить последовательность doc_id в порядке убывания tf-idf для этого слова в этом документе.

Решим задачу в несколько этапов:

1. Создадим граф *split_word*, который пропустит вход нашей исходной таблички через приведенный выше (в описании мэпперов) мэппер, который разделит каждую строку с текстом на много строк - по одной для каждого слова в тексте.

   ```
   split_word := 
        input(‘docs’) ->
        map(split_words)
   ```

2. Создадим граф *count_docs*, который посчитает количество документов в таблице (оно нужно нам для формулы idf). Он будет состоять из единственной функции fold, которая будет считать количество строчек в переданной ей таблице. Результатом этого графа будет таблица с единственной строкой  `{'docs_count' : n}`

   ```
   count_docs := 
        input(‘docs’) -> 
        fold(count_rows)
   ```

3. Создадим граф *count_idf*, считающий idf каждого слова. Входом для этого графа будет выход графа *split_word*.

   Для начала запустим на этой таблице reduce по ключу (‘doc_id’, ‘word’) и для каждого ключа оставим только одно его вхождение (ведь нас интересует количество документов в которых встретилось слово, без разницы сколько раз).

   Далее приджойним  count_docs к каждой строчке нашей таблицы (он нужен для того, чтобы посчитать idf для каждого слова) . Для этого будем пользоваться outer join.

   Результат этой операции будем  сортировать и редьюсить уже по словам (т. е. по 'word') - в нем будем считать количество документов, в которых это слово встретилось. Результатом графа является таблица где для каждого слова посчитан знаменатель формулы tf-idf.

   ```
   count_idf := 
        input(split_words) ->
        sort(‘doc_id’, ‘word’) ->
        reduce(unique, keys=(‘doc_id’, ‘word’)) ->
        join(count_docs, type='outer') ->
        sort(‘word’) ->
        reduce(calc_idf, keys=(‘word’))
   ```

4. Создадим третий граф, *calc_index*. Входом для него так же, как для предыдущего графа, будет результат графа *split_word* - но в этот раз мы его будем редьюсить по документам (по doc_id) и внутри редьюсера будем считать частоту каждого слова, то есть числитель нужной нам формулы (Этот редьюсер приведет в разборе про редьюсеры).

   После этого нужно сделать join c результатом графа *count_idf*. Теперь у нас для каждой пары документ-слово есть и tf, и idf — всё что нужно для победы. Последним будет reduce по ‘word’, считающий ответ — то есть tf-idf для каждой пары слово-документ - и оставляющий для каждого слова top-3 документа по tf-idf.

   ```
   calc_index :=
        input(split_word) ->
        sort('document_id') ->
        reduce(tf, ‘document_id’) ->
        join(count_idf, keys=’word’, ‘type=’left’) ->
        reduce(invert_index, key = ‘word’)
   ```

Теперь для того, чтобы построить инвертированный индекс, достаточно вызвать метод compute у графа calc_index, передав на вход все входы, нужные ему и графам, от которых он зависит, то есть в данном случае просто файл doc для графа *split_word *(обратите внимание, что самому calc_index doc не нужен, и он должен как-то передать его графам, от которых он зависит).
